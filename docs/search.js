window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "biocharStability", "modulename": "biocharStability", "type": "module", "doc": "<p>module: biocharStability</p>\n\n<p>The module <code>biocharStability</code> contains multiple functions used for analysing biochar stability data,  developing biochar stability models, and analysing them.</p>\n\n<p>The functions are split in 4 submodules:</p>\n\n<ul>\n<li>analyse.py</li>\n<li>dashboard.py</li>\n<li>utils.py</li>\n<li>visualize.py</li>\n</ul>\n\n<p>Explore each of them (using the documentation and its menu on the left). Also check out the demo notebooks.</p>\n"}, {"fullname": "biocharStability.analyse", "modulename": "biocharStability.analyse", "type": "module", "doc": "<p>-<em>- coding: utf-8 -</em>-</p>\n\n<p>biochar stability / analyse.py</p>\n\n<p>set of utility functions to analyse the data - i.e. performing curve fitting on the data timeseries, apply Q10 temperature correction, calculate uncertainties on curve fits, build correlation models, ...</p>\n"}, {"fullname": "biocharStability.analyse.singleExp", "modulename": "biocharStability.analyse", "qualname": "singleExp", "type": "function", "doc": "<p></p>\n", "signature": "(t, k)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.k_singleExp", "modulename": "biocharStability.analyse", "qualname": "k_singleExp", "type": "function", "doc": "<p></p>\n", "signature": "(t, k)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.singleExp_u", "modulename": "biocharStability.analyse", "qualname": "singleExp_u", "type": "function", "doc": "<p></p>\n", "signature": "(t, k, c)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.k_singleExp_u", "modulename": "biocharStability.analyse", "qualname": "k_singleExp_u", "type": "function", "doc": "<p></p>\n", "signature": "(t, k, c)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.doubleExp", "modulename": "biocharStability.analyse", "qualname": "doubleExp", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, c1)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.k_doubleExp", "modulename": "biocharStability.analyse", "qualname": "k_doubleExp", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, c1)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.doubleExp_u", "modulename": "biocharStability.analyse", "qualname": "doubleExp_u", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, c1, c2)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.k_doubleExp_u", "modulename": "biocharStability.analyse", "qualname": "k_doubleExp_u", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, c1, c2)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.tripleExp", "modulename": "biocharStability.analyse", "qualname": "tripleExp", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, k3, c1, c2)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.k_tripleExp", "modulename": "biocharStability.analyse", "qualname": "k_tripleExp", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, k3, c1, c2)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.tripleExp_u", "modulename": "biocharStability.analyse", "qualname": "tripleExp_u", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, k3, c1, c2, c3)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.k_tripleExp_u", "modulename": "biocharStability.analyse", "qualname": "k_tripleExp_u", "type": "function", "doc": "<p></p>\n", "signature": "(t, k1, k2, k3, c1, c2, c3)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.powerModel", "modulename": "biocharStability.analyse", "qualname": "powerModel", "type": "function", "doc": "<p></p>\n", "signature": "(t, c0, b, m)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.k_powerModel", "modulename": "biocharStability.analyse", "qualname": "k_powerModel", "type": "function", "doc": "<p></p>\n", "signature": "(t, c0, b, m)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.powerModel_lim", "modulename": "biocharStability.analyse", "qualname": "powerModel_lim", "type": "function", "doc": "<p>This function cannot be used in curve fitting step. Instead, curve fitting should be done with bs.powerModel.\nThen, the fitted parameters on bs.PowerModel are used to calculate the extrapolation with the assumption that the decay rates decreases only for L years.</p>\n\n<ul>\n<li>L = 10*365 # days</li>\n</ul>\n", "signature": "(t, c0, b, m, L=3650)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.powerModel_q10", "modulename": "biocharStability.analyse", "qualname": "powerModel_q10", "type": "function", "doc": "<p></p>\n", "signature": "(t, fT, c0, b, m)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.singleExp_u_lmfit", "modulename": "biocharStability.analyse", "qualname": "singleExp_u_lmfit", "type": "function", "doc": "<p></p>\n", "signature": "(params, x, y)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.doubleExp_u_lmfit", "modulename": "biocharStability.analyse", "qualname": "doubleExp_u_lmfit", "type": "function", "doc": "<p></p>\n", "signature": "(params, x, y)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.rsquare", "modulename": "biocharStability.analyse", "qualname": "rsquare", "type": "function", "doc": "<p>Computes R-square value for given fit</p>\n\n<p>Input: </p>\n\n<pre><code>- f : model function, callable\n\n- xdata: array\n\n- ydata: array\n\n- popt: returned by curve_fit\n</code></pre>\n\n<p>Returns: </p>\n\n<pre><code>- r2\n\n- residuals\n</code></pre>\n", "signature": "(f, xdata, ydata, popt)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.lmfit_fitting_stats", "modulename": "biocharStability.analyse", "qualname": "lmfit_fitting_stats", "type": "function", "doc": "<p>Computes the fitting statistics (chi-square, reduced chi square, AIC, BIC) for a given fit, as implemented in lmfit \n(source: <a href=\"https://github.com/lmfit/lmfit-py/blob/master/lmfit/minimizer.py\">https://github.com/lmfit/lmfit-py/blob/master/lmfit/minimizer.py</a> line 364)\nInput: </p>\n\n<pre><code>- f : model function, callable\n\n- xdata: array\n\n- ydata: array\n\n- popt: returned by curve_fit\n</code></pre>\n\n<p>Outputs: </p>\n\n<pre><code>- chisqr\n\n- redchisqr\n\n- AIC\n\n- BIC\n</code></pre>\n\n<p>Usage: </p>\n\n<pre><code>residuals, chisqr, redchisqr, aic, bic = lmfit_fitting_stats(f, xdata, ydata, popt)\n</code></pre>\n", "signature": "(f, xdata, ydata, popt)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.pretty_covariance", "modulename": "biocharStability.analyse", "qualname": "pretty_covariance", "type": "function", "doc": "<p>Save a pretty covariance matrix as a table, with header names, in wide (matrix) and long dataframes</p>\n\n<p>Usage:</p>\n\n<pre><code>df_matrix, df_long = pretty_covariance(f, p_cov)\n</code></pre>\n", "signature": "(f, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.print_fitting_report", "modulename": "biocharStability.analyse", "qualname": "print_fitting_report", "type": "function", "doc": "<p>Similar to LMFIT report </p>\n\n<pre><code>[[Fit Statistics]]\n    # fitting method   = Nelder-Mead\n    # function evals   = 491\n    # data points      = 44\n    # variables        = 4\n    chi-square         = 3.87297297 \n    reduced chi-square = 0.09682432 \n    Akaike info crit   = -98.9273573\n    Bayesian info crit = -91.7905988\n[[Variables]]\n    k1:  1.1683e-05 +/- 5.1274e-07 (4.39%) (init = 0)\n    k2:  4.47275357 +/- 1.84402220 (41.23%) (init = 0)\n    c1:  97.6338853 +/- 0.07100370 (0.07%) (init = 0)\n    c2:  2.36617997 +/- 0.31931764 (13.50%) (init = 0)\n[[Correlations]] (unreported correlations are &lt; 0.100)\n    C(k1, c1) = 0.729\n    C(k2, c2) = 0.387\n    C(c1, c2) = -0.222\n    C(k1, c2) = -0.162\n    C(k2, c1) = 0.110\n</code></pre>\n", "signature": "(f, xdata, ydata, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.do_the_fit", "modulename": "biocharStability.analyse", "qualname": "do_the_fit", "type": "function", "doc": "<p>Does the fitting for one observation, and returns the parameters of interest, using scipy.curve_fit</p>\n\n<p>Inputs: </p>\n\n<pre><code>- f_model: choose one of the model functions to fit on, e.g. linear, exponential, singleExp, doubleExp, powerModel \n- xdata: timesteps array, in days\n- ydata: decay array\n- p0: initial guess for optimal parameters, in curve_vit, otherwise set to 1\n- method: algorithm for fitting in curve_fit, {lm, trf, dogbox},\n- bounds = upper, and lower limits arrays for fitting parameters, in tuple format (lower_array, upper_array), each array with length of parameters or scalar\n        Here, parameters are either: doubleExp: 0&lt;k1,k2&lt;c1&lt;100\n                                     singleExp: 0&lt;k&lt;c&lt;100\n                                     linear:    0&lt; m &lt; b &lt; 100 (if function defined as -1*m*x + b)\n        TO DO: pass bounds with the function choice?\n</code></pre>\n\n<p>Outputs:  </p>\n\n<pre><code>- fitted paramters, \n- standard deviation of parameters, aboslute and relative\n- covariance matrix of fitted parameters\n- scaled correlations between parameters\n- stability estimates as BC100, apparent MRT, half-life \n- r2 of fit (whether relevant or not)\n- other statisical indicator, chi, ... \n- residuals of fit \n\n- outcome of simple checks (passed failed)\n</code></pre>\n\n<p>Usage:  </p>\n\n<pre><code>p_opt, p_cov, p_std, r2, stab_dict = do_the_fit(f_model=doubleExp, xdata, ydata, p0=None, method=None, bounds=(-1*np.inf, np.inf))\n</code></pre>\n", "signature": "(\n    f_model=<function doubleExp>,\n    xdata=[0],\n    ydata=[0],\n    p0=None,\n    method=None,\n    bounds=(-inf, inf),\n    showPlot=False,\n    full_output=False,\n    maxfev=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.do_the_lmfit", "modulename": "biocharStability.analyse", "qualname": "do_the_lmfit", "type": "function", "doc": "<p>Does the fitting for one observation, and returns the parameters of interest, using lmfit.minimize</p>\n\n<p>Inputs: </p>\n\n<pre><code>- f_model: choose one of the model functions to fit on, e.g. linear, exponential, singleExp, doubleExp, powerModel \n- xdata: timesteps array, in days\n- ydata: decay array\n- bounds = upper, and lower limits arrays for fitting parameters, in tuple format (lower_array, upper_array), each array with length of parameters or scalar\n        Here, parameters are either: doubleExp: 0&lt;k1,k2,c1&lt;100\n                                     singleExp: 0&lt;k&lt;c&lt;100\n                                     linear:    0&lt; m &lt; b &lt; 100 (if function defined as -1*m*x + b)\n</code></pre>\n\n<p>TODO: implement use of initial guess, via p0 - list of initial guesses, in params.add(ar, value=, vary=True)</p>\n", "signature": "(\n    f_model=<function doubleExp_u>,\n    xdata=[0],\n    ydata=[0],\n    method='trf',\n    bounds=(0, 100),\n    showPlot=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.fit_all_observations", "modulename": "biocharStability.analyse", "qualname": "fit_all_observations", "type": "function", "doc": "<p>Applies the fitting_strategies to all passed observations, using the scipy curve_fit function, and returns an extensive report as a list of dictionnary, optionalled saved as an Excel file</p>\n\n<p>USAGE: </p>\n\n<pre><code>df_scipy_fits = bs.fit_all_observations(data, metadata, fitting_strategies=fitting_strategies, library='scipy', variable='C_bc_rem_rel', factor=100, excel='scipy_allfits.xlsx')\n</code></pre>\n", "signature": "(\n    data,\n    metadata,\n    observations=[],\n    fitting_strategies=[],\n    library='scipy',\n    variable='C_bc_rem_rel',\n    factor=100,\n    excel=''\n)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.load_fitted_observations", "modulename": "biocharStability.analyse", "qualname": "load_fitted_observations", "type": "function", "doc": "<p>Load as a dataframe, a previously saved set of fitting_outputs saved as an excel file</p>\n", "signature": "(fp)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.applyQ10", "modulename": "biocharStability.analyse", "qualname": "applyQ10", "type": "function", "doc": "<p>Applies the Q10 re-calibration of soil temperature to a calculated BC100 value at a given soil temperature to the \ntarget soil temperature tTs</p>\n\n<p>Inputs: </p>\n\n<pre><code>- tTs: target soil temperature\n- metadata: dataframe with incubation meta-data\n- fitdata: dataframe containing all the fitting data, usually output of function `fit_all_observations`\n</code></pre>\n\n<p>Outputs:  </p>\n\n<pre><code>- a new dataframe based on fitdata, with a new column containing the recalibrated BC100 values.\n</code></pre>\n", "signature": "(fitdata, metadata, tTs=14.9, verbose=True)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.fit_Q10_data", "modulename": "biocharStability.analyse", "qualname": "fit_Q10_data", "type": "function", "doc": "<p>Fits a relationship between Q10 and soil temperature, based on experimental data compiled.</p>\n\n<p>TODO: load Q10 data from excel, fit exponential model, return model parameters</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "biocharStability.analyse.Q10", "modulename": "biocharStability.analyse", "qualname": "Q10", "type": "function", "doc": "<p>calculate Q10 average factor, based on relationship given Woolf 2021 ES&amp;T</p>\n", "signature": "(T1, T2)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.fT_Woolf", "modulename": "biocharStability.analyse", "qualname": "fT_Woolf", "type": "function", "doc": "<p>calculate the fT ratio of the decay rates at exp temperature Ts over target temperature tTs, based on integration presented in Woolf 2021 ES&amp;T</p>\n", "signature": "(T1, T2)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.fT_WoolfStepwise", "modulename": "biocharStability.analyse", "qualname": "fT_WoolfStepwise", "type": "function", "doc": "<p>Calculates the fT with Woolf2021 method and a stepwise approach</p>\n", "signature": "(T1, T2, s=0.001)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.fT_DataFit", "modulename": "biocharStability.analyse", "qualname": "fT_DataFit", "type": "function", "doc": "<p>from T1 to T2, using exponential relationship fitted on k_Y2 and Incubation temperature of whole dataset, by eye</p>\n", "signature": "(T1, T2)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.applyTempCorr", "modulename": "biocharStability.analyse", "qualname": "applyTempCorr", "type": "function", "doc": "<p>Applies the re-calibration of soil temperature to a calculated BC_TH value at a given soil temperature to the \ntarget soil temperature tTs</p>\n\n<p>Inputs: </p>\n\n<pre><code>- tTs: target soil temperature, in degree C\n- TH: time horizon, in years\n- fT: pass a function used to calculate fT, among the fT availables:\n        - fT_Woolf (or bs.fT_Woolf, if library is imported as bs)\n        - fT_WoolfStepwise (or bs.)\n        - fT_DataFit (or bs.)\n- metadata: dataframe with incubation meta-data\n- fitdata: dataframe containing all the fitting data, usually output of function `fit_all_observations`\n</code></pre>\n\n<p>Outputs:  </p>\n\n<pre><code>- a new dataframe based on fitdata, with a new column containing the recalibrated BC100 values.  \n- list_oldBC100: old values as list\n- list_newBC100: new values as list\n</code></pre>\n", "signature": "(fitdata, metadata, tTs=14.9, TH=100, method=<function fT_Woolf>)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.select_best_fit", "modulename": "biocharStability.analyse", "qualname": "select_best_fit", "type": "function", "doc": "<p>Based on the passed criteria, selects for all observations available fitted_data a single best fit if it exists. </p>\n\n<p>The criterias are:</p>\n\n<ol>\n<li><code>model_pool</code>: a list of model functions names (e.g. <code>singleExp</code>, <code>doubleExp</code>, <code>tripleExp</code>,...) that are considered, for the best fit (e.g. we can decide to exclude powerModel or singleExp)</li>\n<li><code>checks</code>: a dict of ohysical checks that must be passed, to be considered a potential best fit, e.g. {'decay rates positive':TRUE}</li>\n<li><code>spec_val</code>: any other key present in the fitdata data, e.g. {'library':'scipy'} to work only with scipy and exclude lmfit </li>\n<li><code>rank</code>: a tuple, among remaining fits, select the one with lowest/highest score in given goodness indicator, e.g. ('bic', True) means lowest BIC is best</li>\n</ol>\n\n<p>Inputs:</p>\n\n<ul>\n<li>fitdata: a dataframe loaded from Excel, created by function <code>applyQ10</code> or <code>fit_all_observations</code> </li>\n<li>saveExcel: if False, does not save. Alternatively: give filepath to save to.</li>\n</ul>\n\n<p>Outputs:</p>\n\n<ul>\n<li>dataframe, selected best fits for each observations, in same format as fitted_data; the dataframe is also saved as an Excel file (option)</li>\n<li>a list of ID_obs where no best fit was found</li>\n</ul>\n\n<p>USAGE: </p>\n\n<pre><code>no_best, df_best = select_best_fit(fitdata, model_pool, checks, spec_val)\n</code></pre>\n", "signature": "(\n    fitdata,\n    model_pool=[],\n    checks={},\n    spec_val={},\n    rank=('bic', True),\n    saveExcel=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_singleExp", "modulename": "biocharStability.analyse", "qualname": "std_singleExp", "type": "function", "doc": "<p>Given optimal parameters of a fit (p_opt), the covariance matrix of the fitted parameters (p_cov),\ncalculate the propagated error through the model function, based on Talor series expansion of 1st order\n<a href=\"https://en.wikipedia.org/wiki/Propagation_of_uncertainty\">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>\n\n<p>See definition of <code>singleExp</code> for order of parameters</p>\n", "signature": "(t, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_singleExp_u", "modulename": "biocharStability.analyse", "qualname": "std_singleExp_u", "type": "function", "doc": "<p>Given optimal parameters of a fit (p_opt), the covariance matrix of the fitted parameters (p_cov),\ncalculate the propagated error through the model function, based on Talor series expansion of 1st order\n<a href=\"https://en.wikipedia.org/wiki/Propagation_of_uncertainty\">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>\n\n<p>See definition of <code>singleExp_u</code> for order of parameters</p>\n", "signature": "(t, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_doubleExp", "modulename": "biocharStability.analyse", "qualname": "std_doubleExp", "type": "function", "doc": "<p>Given optimal parameters of a fit (p_opt), the covariance matrix of the fitted parameters (p_cov),\ncalculate the propagated error through the double exponential function, based on Talor series expansion of 1st order\n<a href=\"https://en.wikipedia.org/wiki/Propagation_of_uncertainty\">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>\n\n<p>See definition of <code>doubleExp_u</code> for order of parameters</p>\n", "signature": "(t, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_doubleExp_u", "modulename": "biocharStability.analyse", "qualname": "std_doubleExp_u", "type": "function", "doc": "<p>Given optimal parameters of a fit (p_opt), the covariance matrix of the fitted parameters (p_cov),\ncalculate the propagated error through the double exponential function, based on Talor series expansion of 1st order\n<a href=\"https://en.wikipedia.org/wiki/Propagation_of_uncertainty\">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>\n", "signature": "(t, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_tripleExp", "modulename": "biocharStability.analyse", "qualname": "std_tripleExp", "type": "function", "doc": "<p>Given optimal parameters of a fit (p_opt), the covariance matrix of the fitted parameters (p_cov),\ncalculate the propagated error through the triple exponential function, based on Talor series expansion of 1st order\n<a href=\"https://en.wikipedia.org/wiki/Propagation_of_uncertainty\">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>\n", "signature": "(t, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_tripleExp_u", "modulename": "biocharStability.analyse", "qualname": "std_tripleExp_u", "type": "function", "doc": "<p>Given optimal parameters of a fit (p_opt), the covariance matrix of the fitted parameters (p_cov),\ncalculate the propagated error through the triple exponential function, based on Talor series expansion of 1st order\n<a href=\"https://en.wikipedia.org/wiki/Propagation_of_uncertainty\">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>\n", "signature": "(t, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_powerModel", "modulename": "biocharStability.analyse", "qualname": "std_powerModel", "type": "function", "doc": "<p>Given optimal parameters of a fit (p_opt), the covariance matrix of the fitted parameters (p_cov),\ncalculate the propagated error through the model function, based on Talor series expansion of 1st order\n<a href=\"https://en.wikipedia.org/wiki/Propagation_of_uncertainty\">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>\n", "signature": "(t, p_opt, p_cov, fT=1)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_fmodel", "modulename": "biocharStability.analyse", "qualname": "std_fmodel", "type": "function", "doc": "<p>Returns caculated propagated error for the given model, over the entire time range given (xdata)</p>\n", "signature": "(xdata, p_opt, p_cov, fmodel=<function doubleExp_u>)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.rebuild_cov2", "modulename": "biocharStability.analyse", "qualname": "rebuild_cov2", "type": "function", "doc": "<p>Rebuild the covariance matrix, in correct order from data saved as Excel dataframe.</p>\n", "signature": "(f_model, params, stdev, covar)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.apply_Q10_bis", "modulename": "biocharStability.analyse", "qualname": "apply_Q10_bis", "type": "function", "doc": "<p>Given an observation, its model function, its parameters, a given TH and TS, the function:</p>\n\n<ul>\n<li>calculates BC_TH_TS remaining at any given TH and TS</li>\n<li>calculates a propagaged error on BC_TH_TS based on fitting uncertainty of fitted params</li>\n</ul>\n\n<p>IMPROVEMENT/TODO: at the moment, does not include uncertaity from the Q10 temperature correction (would need uncertainty in fit kT, Q10, as well as new derative calculations)</p>\n", "signature": "(Th, tTs, Ts, FIT_func, params, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.correlation_linear", "modulename": "biocharStability.analyse", "qualname": "correlation_linear", "type": "function", "doc": "<p>Performs a linear correlation between the two variables x and y (which must be one column in either fitdata or metadata),\nfor a given soil temperature and a time horizon (if relevant, usually the case, when calculating BC_t). </p>\n\n<p>Normal use case:</p>\n\n<ul>\n<li>y='BC_Th_Ts' will calculate amount of biochar C remaining at Th and Ts passed as argument; while x is usually taken from the metadata columns</li>\n<li>x must be from a metadata column, e.g. H/C_org, H/C_tot, HHT, Carbon, Carbon, organic, or another accepted value (currently H/C_all only)\n<ul>\n<li>If <code>x = H/C_all</code>, then the metadata considered will be: H/C_org whenever available, and H/C_tot to bridge gaps.</li>\n</ul></li>\n</ul>\n\n<ul>\n<li>At time of plotting, the function will return the number of observations dropped due to missing data. </li>\n<li>Selected <code>outliers</code> can be removed by specifying a list of ID_obs </li>\n<li>Plotting can be done in static manner, or interactive mode (with sliders)</li>\n</ul>\n", "signature": "(\n    fitdata,\n    metadata,\n    x,\n    y='BC_Th_Ts',\n    Ts=15,\n    Th=100,\n    plot=True,\n    interactive=False,\n    ax=None,\n    outliers=None,\n    ifig=None,\n    iobs=None,\n    trendline=True,\n    trenderror=False,\n    wSigma=False,\n    an=False,\n    figsize=(9, 6)\n)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.linear", "modulename": "biocharStability.analyse", "qualname": "linear", "type": "function", "doc": "<p></p>\n", "signature": "(x, a, b)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.std_linear", "modulename": "biocharStability.analyse", "qualname": "std_linear", "type": "function", "doc": "<p></p>\n", "signature": "(x, p_opt, p_cov)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.calc_correlation_timeseries", "modulename": "biocharStability.analyse", "qualname": "calc_correlation_timeseries", "type": "function", "doc": "<p>Function can be used to calculate timesesries of BC_TH_TS, based on a linear fit between BC_TH_TS and H/C_all, for any TH and TS. </p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>Ts: a list of values, or a single value provided as a list- soil temperatures to consider</li>\n<li>Th: a list of values, or a single value provided as a list- time points to calculate</li>\n<li>x : a list of values, or a single value provided as a list - variable in metadata to use for correlation (single variable or multiple variable)</li>\n<li>outliers: a list of ID_obs to exclude from analysis</li>\n</ul>\n\n<p>Outputs:</p>\n\n<ul>\n<li>vX: vector of X variable, for selected observations where data available</li>\n<li>vXnan: list of ID_obs where X variable is NaN</li>\n<li>megaY: dictionnary of calculated Y (BC_TH_TS), where keys are (TS, TH) tuples, and values are the corresponding BC_TH_TS for each observations</li>\n<li>megaYnan: list of ID_obs where Y variable is NaN</li>\n<li>megaCoeffs: for each (TS, TH), coefficients from the linear regression (slope, intercept)</li>\n<li>megaSCoeffs: for each (TS, TH), covariance matrix from the linear regression</li>\n</ul>\n\n<p>Usage: </p>\n\n<pre><code>vX, vXnan, megaY, megaYnan, megaCoeffs, megaSCoeffs = calc_correlation_timeseries(fitdata, metadata,\n                        x = ['H/C_all'], outliers=None, Ts=[10, 15, 20],\n                        Th=[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 120, 140, 160, 180, 200],\n                       )\n</code></pre>\n", "signature": "(\n    fitdata,\n    metadata,\n    x=['H/C_all'],\n    outliers=None,\n    Ts=[10, 15, 20],\n    Th=[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 120, 140, 160, 180, 200]\n)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.plot_correlation_timeseries", "modulename": "biocharStability.analyse", "qualname": "plot_correlation_timeseries", "type": "function", "doc": "<p>Plot the results computed via <code>calc_correlation_timeseries</code>.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>x = values of X that need to be plotted, as a list // if multiple variables; should be a dictionnary of key:[values]</li>\n</ul>\n\n<p>Outputs:</p>\n\n<ul>\n<li>fig, ax</li>\n</ul>\n", "signature": "(\n    fitdata,\n    metadata,\n    x,\n    Ts,\n    Th,\n    vX,\n    vXnan,\n    megaY,\n    megaYnan,\n    megaCoeffs,\n    megaSCoeffs,\n    fig=None,\n    ax=None,\n    TH_lim=1000\n)", "funcdef": "def"}, {"fullname": "biocharStability.analyse.pick_model", "modulename": "biocharStability.analyse", "qualname": "pick_model", "type": "function", "doc": "<p>Pick the a random forest model <code>k</code> from <code>df</code> and re-trains it with its optimal parameters, on the data set (X,Y).</p>\n\n<ul>\n<li>k: row index of the model in the dataframe df, corresponding also to set index in dictionary sets</li>\n<li>df: df containing the model optimal parameters, as well as r2, r2a, features</li>\n<li>sets: dictionnary of sets </li>\n<li>X, Y: the training data/target</li>\n</ul>\n", "signature": "(k, df, sets, X, Y)", "funcdef": "def"}, {"fullname": "biocharStability.dashboard", "modulename": "biocharStability.dashboard", "type": "module", "doc": "<p>-<em>- coding: utf-8 -</em>-</p>\n\n<p>biochar stability / dashboard.py</p>\n\n<p>set of utility functions to create interactive bokeh dashboard from the data</p>\n"}, {"fullname": "biocharStability.dashboard.generate_bokeh_app", "modulename": "biocharStability.dashboard", "qualname": "generate_bokeh_app", "type": "function", "doc": "<p>BOKEH - Generate and saves the bokeh components (as javascript files) and the static app (as markdown for hugo website, from template file), based on the list of components passed as argument.</p>\n\n<p>USAGE: </p>\n\n<pre><code>generate_bokeh_app(\n    component_ids=[1, 2], # must be present in the template .md file used as input\n    component_js_names=['component_1', 'component_2'], # free to choose the name of the js file\n    bokeh_elements=[component_1, component_2], # bokeh objects available in the notebook\n    md_outpout_file = 'C:/github/biochar-systems-dev/content/en/stability/app.md',\n    js_output_file_dir = 'C:/github/biochar-systems-dev/content/en/stability/',\n)\n</code></pre>\n", "signature": "(\n    component_ids=[],\n    component_js_names=[],\n    bokeh_elements=[],\n    md_template_file='dashboard-app-template.md',\n    md_outpout_file='bokeh-app/app.md',\n    js_output_file_dir='bokeh-app/'\n)", "funcdef": "def"}, {"fullname": "biocharStability.dashboard.merge_data_metadata", "modulename": "biocharStability.dashboard", "qualname": "merge_data_metadata", "type": "function", "doc": "<p>Merges the data and metadata as a single dataframe, with lists as cell concent for the timeseries in data.</p>\n\n<p>Returns either a dataframe (if asCDS = False), or a ColumnDataSource (if asCDR=True) useful for bokeh plots.</p>\n\n<p>USAGE: </p>\n\n<pre><code>datametadata = merge_data_metadata(data, metadata, asCDS=False)\n</code></pre>\n\n<p>OR </p>\n\n<pre><code>TheSource = merge_data_metadata(data, metadata, asCDS=True)\n</code></pre>\n", "signature": "(data, metadata, asCDS=False)", "funcdef": "def"}, {"fullname": "biocharStability.dashboard.make_scatter", "modulename": "biocharStability.dashboard", "qualname": "make_scatter", "type": "function", "doc": "<p>BOKEK - create and return a scatter plot object, which can be inserted in a grid layout. Used for making pairplots (with scatter and histograms).</p>\n", "signature": "(\n    xname,\n    yname,\n    xRanges,\n    yRanges,\n    src,\n    x_axis_label='X Axis',\n    y_axis_label='Y Axis',\n    xax=False,\n    yax=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.dashboard.make_histogram", "modulename": "biocharStability.dashboard", "qualname": "make_histogram", "type": "function", "doc": "<p>BOKEH - create and return a scatter histogram object, where histogram bins are built with numpy</p>\n", "signature": "(\n    x,\n    df,\n    x_axis_label='X Axis',\n    y_axis_label='Y Axis',\n    xax=False,\n    yax=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils", "modulename": "biocharStability.utils", "type": "module", "doc": "<p>-<em>- coding: utf-8 -</em>-</p>\n\n<p>biochar stability / utils.py</p>\n\n<p>set of utility functions to load, handle, save the data</p>\n"}, {"fullname": "biocharStability.utils.load_metadata", "modulename": "biocharStability.utils", "qualname": "load_metadata", "type": "function", "doc": "<p>From the biochar stability database (.xlsx), loads the metadata sheets and parse the appropriate formats to the various columns.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>pandas dataframe, metadata</li>\n<li>pandas dataframe, schema</li>\n<li>dictionary, metadata_column_sets (column names of metadata, grouped by categories (id, bio, pyr, incub, char) and numerical/non-numerical data type)</li>\n</ul>\n\n<p>Usage: </p>\n\n<pre><code>metadata, schema, metadata_column_sets = load_metadata(filepath='biochar_incubation_database_2022-03-22_v0.xlsx', sheet_name='metadata', index_col=None, usecols='A:BN', skiprows=3, schema_rows=6, last_row=None)\n</code></pre>\n", "signature": "(\n    filepath,\n    sheet_name='metadata',\n    index_col=None,\n    usecols='A:BN',\n    skiprows=3,\n    schema_rows=6,\n    last_row=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.load_data", "modulename": "biocharStability.utils", "qualname": "load_data", "type": "function", "doc": "<p>From the biochar stability database (.xlsx), loads the data sheet</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>pandas dataframe, data</li>\n</ul>\n\n<p>Usage: </p>\n\n<pre><code>data = load_metadata(filepath='biochar_incubation_database_2022-03-22_v0.xlsx')\n</code></pre>\n", "signature": "(\n    filepath,\n    sheet_name='data',\n    index_col=None,\n    usecols='A:AA',\n    skiprows=3,\n    schema_rows=4,\n    last_row=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.load_articles", "modulename": "biocharStability.utils", "qualname": "load_articles", "type": "function", "doc": "<p>From the biochar stability database (.xlsx), loads the article sheet</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>pandas dataframe, articles</li>\n</ul>\n\n<p>Usage: </p>\n\n<pre><code>articles = load_articles(filepath='biochar_incubation_database_2022-03-22_v0.xlsx')\n</code></pre>\n", "signature": "(\n    filepath,\n    sheet_name='articles',\n    index_col=None,\n    usecols='A:P',\n    skiprows=3,\n    schema_rows=3,\n    last_row=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.load_validation", "modulename": "biocharStability.utils", "qualname": "load_validation", "type": "function", "doc": "<p>From the biochar stability database (.xlsx), loads the article sheet</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>pandas dataframe, articles</li>\n</ul>\n\n<p>Usage: </p>\n\n<pre><code>validation = load_validation(filepath='biochar_incubation_database_2022-03-22_v0.xlsx')\n</code></pre>\n", "signature": "(\n    filepath,\n    sheet_name='validation',\n    index_col=None,\n    usecols='A:DD',\n    skiprows=3,\n    schema_rows=1,\n    last_row=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.load_q10data", "modulename": "biocharStability.utils", "qualname": "load_q10data", "type": "function", "doc": "<p>From the biochar q10 database (.xlsx), loads the data sheet</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>pandas dataframe, data</li>\n</ul>\n\n<p>Usage: </p>\n\n<pre><code>data = load_metadata(filepath='biochar_incubation_database_2022-03-22_v0.xlsx')\n</code></pre>\n", "signature": "(\n    filepath='biocharStability/database/biochar_q10_dataset_2022-05-27.xlsx',\n    sheet_name='q10',\n    index_col=None,\n    usecols='B:Q',\n    skiprows=1,\n    schema_rows=0,\n    last_row=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.print_database_completion_stats", "modulename": "biocharStability.utils", "qualname": "print_database_completion_stats", "type": "function", "doc": "<p>Displays some basic statistics about the loaded dataframes, if passed as argument</p>\n", "signature": "(\n    articles=None,\n    data=None,\n    metadata=None,\n    validation=None,\n    schema=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.stats_by_class", "modulename": "biocharStability.utils", "qualname": "stats_by_class", "type": "function", "doc": "<p></p>\n", "signature": "(df, c='BiomassClass', display=False, style='github')", "funcdef": "def"}, {"fullname": "biocharStability.utils.print_metadata_stats", "modulename": "biocharStability.utils", "qualname": "print_metadata_stats", "type": "function", "doc": "<p>Displays some statistics about the metadata available in the database, including:</p>\n\n<ul>\n<li>table, biomass classes</li>\n<li>table, pyrolysis classes</li>\n</ul>\n", "signature": "(metadata)", "funcdef": "def"}, {"fullname": "biocharStability.utils.select_mineralization_data", "modulename": "biocharStability.utils", "qualname": "select_mineralization_data", "type": "function", "doc": "<p>Selects timeseries from data dataframe, for given observations. Does not raise warning if requested ID is not present in the data</p>\n\n<p>Returns: </p>\n\n<ul>\n<li>copy of subset of dataframe</li>\n</ul>\n", "signature": "(ID_obs, data)", "funcdef": "def"}, {"fullname": "biocharStability.utils.select_timeseries", "modulename": "biocharStability.utils", "qualname": "select_timeseries", "type": "function", "doc": "<p>Select a specific timeseries, for a single observations for the given column.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>numpy arrays of x (time) and y (col_to_plot), useful for plotting or curve_fitting</li>\n</ul>\n\n<p>Also applies checks if the data is available for that observation, and raises exception otherwise.</p>\n", "signature": "(ID_obs, data, col_to_plot, factor=1)", "funcdef": "def"}, {"fullname": "biocharStability.utils.classify_observations_by_duration", "modulename": "biocharStability.utils", "qualname": "classify_observations_by_duration", "type": "function", "doc": "<p>Creates a list of sets, each set containing the ID_obs of the observations being longer than x months.</p>\n\n<ul>\n<li>[60, 48 , 24, 12, 10, 0] # 6 groups</li>\n<li>[30, 15, 12, 10, 0] # 6 groups</li>\n</ul>\n\n<p>USAGE: </p>\n\n<pre><code>months_cutoffs, sets_incubations, sets_labels = bs.classify_observations_by_duration(metadata)\n</code></pre>\n", "signature": "(metadata, months_cutoffs=[30, 20, 12, 0])", "funcdef": "def"}, {"fullname": "biocharStability.utils.merge_dfs", "modulename": "biocharStability.utils", "qualname": "merge_dfs", "type": "function", "doc": "<p>Merge a list of dataframes <code>dfs</code>, with same columns, using pd.concat, and re-index it all</p>\n", "signature": "(dfs, saveTo=False)", "funcdef": "def"}, {"fullname": "biocharStability.utils.intersection", "modulename": "biocharStability.utils", "qualname": "intersection", "type": "function", "doc": "<p>Returns the intersection of two lists</p>\n", "signature": "(lst1, lst2)", "funcdef": "def"}, {"fullname": "biocharStability.utils.apply_has_decay_data", "modulename": "biocharStability.utils", "qualname": "apply_has_decay_data", "type": "function", "doc": "<p>Exclude from the passed list of observations, observations which do not have decay data</p>\n\n<p>Function will:\n    - print the number of observations exlcuded.\n    - return the new list of observations\n    - raise error if the new list is empty</p>\n", "signature": "(obs, metadata, data, withPrint=True)", "funcdef": "def"}, {"fullname": "biocharStability.utils.apply_exclude_by_duration", "modulename": "biocharStability.utils", "qualname": "apply_exclude_by_duration", "type": "function", "doc": "<p>Exclude from the passed list of observations, observations with durations shorter/longer than the parameters specified (expressed in days)</p>\n\n<p>Function will:\n    - print the number of observations exlcuded.\n    - return the new list of observations\n    - raise error if the new list is empty</p>\n", "signature": "(\n    obs,\n    metadata,\n    excl_shorter_than=None,\n    excl_longer_than=None,\n    withPrint=True\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.apply_exclude_by_numeric", "modulename": "biocharStability.utils", "qualname": "apply_exclude_by_numeric", "type": "function", "doc": "<p>Exclude from the passed list of observations, observations with <code>var</code> lower/higher than the parameters specified (expressed in same unit as in metadata)</p>\n\n<p>Function will:\n    - print the number of observations exlcuded.\n    - return the new list of observations\n    - raise error if the new list is empty</p>\n", "signature": "(\n    obs,\n    metadata,\n    var='HHT',\n    excl_lower_than=None,\n    excl_higher_than=None,\n    withPrint=True\n)", "funcdef": "def"}, {"fullname": "biocharStability.utils.apply_exclude_exactly", "modulename": "biocharStability.utils", "qualname": "apply_exclude_exactly", "type": "function", "doc": "<p>Exclude exactly the observations passed in the list excl.</p>\n\n<p>Function will:\n    - print the number of observations exlcuded.\n    - return the new list of observations\n    - raise error if the new list is empty</p>\n", "signature": "(obs, excl=[], withPrint=True)", "funcdef": "def"}, {"fullname": "biocharStability.utils.apply_intersect_best_fits", "modulename": "biocharStability.utils", "qualname": "apply_intersect_best_fits", "type": "function", "doc": "<p>Returns a dataframe of the best fits to use for the modelling, based on a list of observation passed.</p>\n", "signature": "(obs, df_best)", "funcdef": "def"}, {"fullname": "biocharStability.utils.obs_per_feat", "modulename": "biocharStability.utils", "qualname": "obs_per_feat", "type": "function", "doc": "<p>Given a metadata df with a subset of relevant features, counts number of nan, and plots nb of observations available without nan as a function of features</p>\n", "signature": "(X, plot=True)", "funcdef": "def"}, {"fullname": "biocharStability.utils.featcombin", "modulename": "biocharStability.utils", "qualname": "featcombin", "type": "function", "doc": "<p>Given a metadata df where columns are relevant features, creates a list containing lists of all combination of features, without repetititons</p>\n", "signature": "(X, n, m=0)", "funcdef": "def"}, {"fullname": "biocharStability.utils.dry2daf", "modulename": "biocharStability.utils", "qualname": "dry2daf", "type": "function", "doc": "<p>Convert quantity x expressed in dry-basis to a dry-ash-free basis, with ash content specified.\nNew columns: named as <code>x_daf</code>\nHow are NaNs handled: NaNs in one colum remain NaNs</p>\n", "signature": "(df, x, ash='Ash')", "funcdef": "def"}, {"fullname": "biocharStability.visualize", "modulename": "biocharStability.visualize", "type": "module", "doc": "<p>-<em>- coding: utf-8 -</em>-</p>\n\n<p>biochar stability / visualize.py </p>\n\n<p>set of utility functions to visualise the data and export static figures (matplotlib, ternary)</p>\n"}, {"fullname": "biocharStability.visualize.make_corr_scatter", "modulename": "biocharStability.visualize", "qualname": "make_corr_scatter", "type": "function", "doc": "<p>Plot of scatter between two columns of the passed dataframe, with options to set color and marker via other columns, and annotate each datapoint.</p>\n", "signature": "(\n    df,\n    x='HHT',\n    y='BC_100',\n    c='BiomassClass',\n    m='PyrolysisClass',\n    an=False,\n    fi=None,\n    fig=None,\n    ax=None,\n    saveFig=False,\n    figsize=(6, 6)\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_timeseries_by_group", "modulename": "biocharStability.visualize", "qualname": "plot_timeseries_by_group", "type": "function", "doc": "<p>Using matplotlib, create scatter plots of timeseries from the incubation data, grouped according to the sets of observations passed as argument (e.g. by experimental duration, by type of biomass).</p>\n\n<p>Note: if timeseries values shall be converted (e.g. decay rates from fraction/day to %/year) perform the conversion on the data. Alternatively use the parameter <code>factor</code>.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>data: data df</li>\n<li>metadata: metadata df</li>\n<li>obs_sets: list of sets of integers, corresponding ot ID_obs </li>\n<li>col_to_plot: str, corresponding to the column from data to plot, usually 'C_bc_rem_rel' or 'k_bc_reld'</li>\n<li>exclude_obs: can be used to exclude specific observations (e.g. the ones corresponding to non-pyrolysed biomass)</li>\n<li>titles: list of str, titles for each subplot</li>\n<li>others matplotlib parameters</li>\n</ul>\n", "signature": "(\n    data,\n    metadata,\n    obs_sets,\n    col_to_plot='C_bc_rem_rel',\n    exclude_obs=[49, 56],\n    titles=['a. Incubations longer than 30 months (17 obs)', 'b. Incubations between 20 and 30 months (38 obs)', 'c. Incubations between 12 and 20 months (15 obs)', 'd. Incubations shorter than 12 months (58 obs)'],\n    ylabel='Timeseries',\n    legend_title='Categories',\n    factor=1,\n    marker_list=['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],\n    color_list=[(0.86, 0.3712, 0.33999999999999997), (0.86, 0.7612000000000001, 0.33999999999999997), (0.5688000000000001, 0.86, 0.33999999999999997), (0.33999999999999997, 0.86, 0.5012000000000001), (0.33999999999999997, 0.8287999999999999, 0.86), (0.33999999999999997, 0.43879999999999986, 0.86), (0.6311999999999998, 0.33999999999999997, 0.86), (0.86, 0.33999999999999997, 0.6987999999999996)],\n    line=False,\n    lw=0.35,\n    nrows=2,\n    ncols=2,\n    figsize=(16, 10),\n    saveFig=False,\n    pathFig='img/timeseries_for_.png',\n    dpiFig=300\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.sort_params", "modulename": "biocharStability.visualize", "qualname": "sort_params", "type": "function", "doc": "<p>Sort parameters from the dataframe, so they match the order of the params in the model function.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>f_model : a python function, with arguments (t, p1, p2, p3)</li>\n<li>params : a dataframe</li>\n</ul>\n\n<p>Returns: </p>\n\n<ul>\n<li>f_params: list of param names (str) in the order of f_model </li>\n<li>p_opt_values: values of the params, in same order as required by f_model</li>\n</ul>\n", "signature": "(f_model, params)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.select_multi_fits", "modulename": "biocharStability.visualize", "qualname": "select_multi_fits", "type": "function", "doc": "<p>Prepare the data, for plotting multiple fits. This includes:</p>\n\n<ul>\n<li>selecting the time series data for a given <code>ID_obs</code>, and <code>col_to_plot ='C_bc_rem_rel'</code></li>\n<li>performs physical checks on the fitted data, if <code>exclude_non_physical=True</code></li>\n<li>ranks fits according to <code>fit_rank</code>, and <code>fit_ascending=True</code></li>\n</ul>\n", "signature": "(\n    ID_obs,\n    fitdata,\n    data,\n    metadata,\n    fit_limit=None,\n    fit_rank='bic',\n    fit_ascending=True,\n    exclude_non_physical=False,\n    col_to_plot='C_bc_rem_rel'\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits", "type": "function", "doc": "<p>Plots a set fitting, for a given observation given by its ID_obs, alongside the decomposition data. Plot is added to a given axis, if passed.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>fit_limit: how many fit to plot among available; if None, plots all available, if less (int) e.g. 5 only plots 5 based on the fit_rank parameter</li>\n<li>fit_rank: default <code>bic</code>, ranks the fits from lowest to highest <code>bic</code>, the lowest, the better (must be one of the goodness estimator (r2, chisqr, redchisqr, aic, bic)</li>\n</ul>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_decay", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_decay", "type": "function", "doc": "<p>Plots a set fitting, for a given observation given by its ID_obs, alongside the decomposition data. Plot is added to a given axis, if passed.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>fit_limit: how many fit to plot among available; if None, plots all available, if less (int) e.g. 5 only plots 5 based on the fit_rank parameter</li>\n<li>fit_rank: default <code>bic</code>, ranks the fits from lowest to highest <code>bic</code>, the lowest, the better (must be one of the goodness estimator (r2, chisqr, redchisqr, aic, bic)</li>\n</ul>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    factor=1,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_extended", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_extended", "type": "function", "doc": "<p>Plots the decay curves etrapolated to 100 years. Plot is added to a given axis, if passed.</p>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    TH=101,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_extended_decay", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_extended_decay", "type": "function", "doc": "<p>Plots the decay curves etrapolated to 100 years. Plot is added to a given axis, if passed.</p>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    TH=101,\n    factor=1,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_residuals", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_residuals", "type": "function", "doc": "<p>Plots the residuals of the fits. Plot is added to a given axis, if passed.</p>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_report", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_report", "type": "function", "doc": "<p>Plots the residuals of the fits. Plot is added to a given axis, if passed.</p>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    columns=None,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_snapshots", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_snapshots", "type": "function", "doc": "<p>Plots amount of biochar C remaining after times given as years in snapshots. Plot is added to a given axis, if passed.</p>\n\n<p>e.g. snapshots=[100, 200, 500] &gt; 100 years, 200 years, 500 years</p>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    snapshots=[100, 200, 500],\n    fs=18,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_snapshots_q10", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_snapshots_q10", "type": "function", "doc": "<p>Plots amount of biochar C remaining after times given as years in snapshots. Plot is added to a given axis, if passed.</p>\n\n<pre><code>e.g. snapshots=[100, 200, 500] &gt; 100 years, 200 years, 500 years\n</code></pre>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    snapshots=[100, 200, 500],\n    tTs=14.9,\n    fs=18,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.rebuild_cov", "modulename": "biocharStability.visualize", "qualname": "rebuild_cov", "type": "function", "doc": "<p>Rebuild the covariance matrix, in correct order from data saved as Excel...</p>\n", "signature": "(f_model, params, stdev, covar)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_best_fits_uncertainty", "modulename": "biocharStability.visualize", "qualname": "plot_best_fits_uncertainty", "type": "function", "doc": "<p>Plots the selected best fits, with their uncertainty ranges. Plot is added to a given axis, if passed.</p>\n\n<ul>\n<li>bic_limit=3 &gt;&gt; only plots the 3 best fits, ranked by lowest bic</li>\n</ul>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    bic_limit=3,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_multi_fits_template", "modulename": "biocharStability.visualize", "qualname": "plot_multi_fits_template", "type": "function", "doc": "<p>Just a template function, serving as a base structure for plotting results from fits.</p>\n\n<p>Plot is added to a given axis, if passed.</p>\n", "signature": "(\n    ID_obs,\n    x,\n    y,\n    xdataHighRes,\n    sub,\n    metadata,\n    ax=None,\n    fig=None,\n    saveTo=False\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_woolf_comparison", "modulename": "biocharStability.visualize", "qualname": "plot_woolf_comparison", "type": "function", "doc": "<p></p>\n", "signature": "(\n    ID_obs,\n    subset_fitdata_ext,\n    data,\n    metadata,\n    saveTo='simulations/woolf-comparison-p0/'\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_pca_biplot", "modulename": "biocharStability.visualize", "qualname": "plot_pca_biplot", "type": "function", "doc": "<p>For 2 given components c1 and c2 (numbered from 0), plots a PCA scatter plot &amp; a loading plot (arrows, with max limfeat sorted by longer arrows).</p>\n\n<p>Y = </p>\n\n<p>More info:\n<a href=\"https://ostwalprasad.github.io/machine-learning/PCA-using-python.html\">https://ostwalprasad.github.io/machine-learning/PCA-using-python.html</a>\n<a href=\"https://www.nonlinear.com/support/progenesis/comet/faq/v2.0/pca.aspx\">https://www.nonlinear.com/support/progenesis/comet/faq/v2.0/pca.aspx</a></p>\n", "signature": "(\n    projection,\n    components,\n    features,\n    c1,\n    c2,\n    limfeat=5,\n    Y=None,\n    fig=None,\n    ax=None,\n    cbartxt=False,\n    annotate=False,\n    texts=None\n)", "funcdef": "def"}, {"fullname": "biocharStability.visualize.plot_RF_model", "modulename": "biocharStability.visualize", "qualname": "plot_RF_model", "type": "function", "doc": "<p>Plots the outcome of a trained random forest regressor (rf) over a given feature space (xs), selecting which target variable to plot with (ys).</p>\n\n<ul>\n<li>If xs has 1 dimension (1 feature), then it's a simple 2D plot.</li>\n<li>If xs has 2 dimensions, and both are continuous variables; then it's a 2D plot with permanence as color</li>\n<li>If xs has 3 dimensions, and 1 of them is a discrete variable; then, we can plot as a 2D plot, for each value of the discrete variable\n...</li>\n</ul>\n\n<p>Input:</p>\n\n<ul>\n<li>rf: a sklearn regressor, with the rf.predict() method</li>\n<li>xs: a list of np.arrays with values for each features, order of features must be same as in rf.features_names_in_ , </li>\n<li>ys: which target variables to select, if several ones</li>\n<li>ylabel: list of corresponding text labels for the different target variables</li>\n<li>fX, fY: the original datataset, for plotting as scatter onto the visualisation</li>\n</ul>\n", "signature": "(\n    rf,\n    xs,\n    ycols=0,\n    ylabel='',\n    fig=None,\n    ax=None,\n    figsize=(10, 3),\n    fX=None,\n    fY=None\n)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();